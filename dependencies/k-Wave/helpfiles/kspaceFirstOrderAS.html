<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>kspaceFirstOrderAS :: Functions (k-Wave)</title>
	<link rel="stylesheet" href="kwavehelpstyle.css" type="text/css">
</head>

<body>
<div class="content">

<h1>kspaceFirstOrderAS</h1>
<p class="purpose">Axisymmetric time-domain simulation of wave propagation.</p>

<h2>Syntax</h2>

<pre class="codeinput">
sensor_data = kspaceFirstOrderAS(kgrid, medium, source, sensor)
sensor_data = kspaceFirstOrderAS(kgrid, medium, source, sensor, ...) 
</pre>

<h2>Description</h2>
<p><code>kspaceFirstOrderAS</code> simulates the time-domain propagation of compressional waves through an axisymmetric homogeneous or heterogeneous acoustic medium. The code is functionally very similar to <code><a href="kspaceFirstOrder2D.html">kspaceFirstOrder2D</a></code>. However, a 2D axisymmetric coordinate system is used instead of a 2D Cartesian coordinate system. In this case, <code>x</code> corresponds to the axial dimension, and <code>y</code> corresponds to the radial dimension as shown below. In the radial dimension, the first grid point corresponds to the grid origin, i.e., <code>y = 0</code>. In comparison, for <code><a href="kspaceFirstOrder2D.html">kspaceFirstOrder2D</a></code>, the Cartesian point <code>y = 0</code> is in the middle of the computational grid.</p>

<img vspace="5" hspace="5" src="images/kspaceFirstOrderAS_01.png" style="width:176px;height:250px;" alt="">

<p>The input structures <code>kgrid</code>, <code>medium</code>, <code>source</code>, and <code>sensor</code> are defined in exactly the same way as for <code><a href="kspaceFirstOrder2D.html">kspaceFirstOrder2D</a></code>. However, computationally, there are several key differences. First, the axisymmetric code solves the coupled first-order equations accounting for viscous absorption (not power law), so only <code>medium.alpha_power = 2</code> is supported. This value is set by default, and doesn't need to be defined. This also means that <code>medium.alpha_mode</code> and <code>medium.alpha_filter</code> are not supported. Second, for a homogeneous medium, the k-space correction used to counteract the numerical dispersion introduced by the finite-difference time step is not exact (as it is for the other fluid codes). However, the approximate k-space correction still works very effectively, so dispersion errors should still be small. See <code><a href="kspaceFirstOrder2D.html">kspaceFirstOrder2D</a></code> for additional details on the function inputs.</p>

<p>In the x-dimension (axial), the FFT is used to compute spatial gradients. In the y-dimension (radial), two choices of symmetry are possible. These are whole-sample-symmetric on the interior radial boundary (y = 0) and either whole-sample-symmetric or whole-sample-asymmetric on the exterior radial boundary. These are abbreviated WSWA and WSWS. The WSWA and WSWS symmetries are implemented using both discrete trigonometric transforms (DTTs), and via the FFT by manually mirroring the domain. The latter options are abbreviated as WSWA-FFT and WSWS-FFT. The WSWA/WSWS options and the corresponding WSWA-FFT/WSWS-FFT options agree to machine precision. When using the PML, the choice of symmetry doesn't matter, and all options give very similar results (to several decimal places). Computationally, the DTT implementations are more efficient, but require additional compiled MATLAB functions (not currently part of k-Wave). The symmetry can be set by using the optional input <code>'RadialSymmetry'</code>. The WSWA-FFT symmetry is set by default.</p>

<h2>Inputs</h2>

<p>The minimum fields that must be assigned to run an initial value problem (for example, a photoacoustic forward simulation) are marked with a *.</p>

<table class="body">

    <tr valign="top">
        <td width = "150"><code>kgrid*</code></td>
        <td>k-Wave grid object returned by <code><a href="kWaveGrid.html">kWaveGrid</a></code> containing axisymmetric and k-space grid fields</td>
    </tr>    
    
    <tr valign="top">
        <td width = "150"><code>kgrid.t_array*</code></td>
        <td>
            <p>evenly spaced array of time values [s] (set to <code>'auto'</code> by <code><a href="kWaveGrid.html">kWaveGrid</a></code>)</p>
        </td>
    </tr>  
    
    <tr valign="top">
        <td>&nbsp</td>
        <td>&nbsp</td>
    </tr>       
    
    <tr valign="top">
        <td><code>medium.sound_speed*</code></td>
        <td>sound speed distribution within the acoustic medium [m/s]</td>
    </tr>  
    
    <tr valign="top">
        <td><code>medium.sound_speed_ref</code></td>
        <td>reference sound speed used within the k-space operator (phase correction term) [m/s]</td>
    </tr>  	
	
    <tr valign="top">
        <td><code>medium.density*</code></td>
        <td>density distribution within the acoustic medium [kg/m^3]</td>
    </tr>    

    <tr valign="top">
        <td><code>medium.BonA</code></td>
        <td>parameter of nonlinearity</td>
    </tr>  	
    
    <tr valign="top">
        <td><code>medium.alpha_coeff</code></td>
        <td>power law absorption coefficient [dB/(MHz^y cm)]</td>
    </tr>     

    <tr valign="top">
        <td><code>medium.alpha_sign</code></td>
        <td>scalar used to control the sign of the absorption term in the equation of state</td>
    </tr>  

    <tr valign="top">
        <td>&nbsp</td>
        <td>&nbsp</td>
    </tr>       
    
    <tr valign="top">
        <td><code>source.p0*</code></td>
        <td>initial pressure within the acoustic medium</td>
    </tr>     
  
    <tr valign="top">
        <td><code>source.p</code></td>
        <td>time varying pressure at each of the source positions given by <code>source.p_mask</code></td>
    </tr>         
    
    <tr valign="top">
        <td><code>source.p_mask</code></td>
        <td>binary matrix specifying the positions of the time varying pressure source distribution</td>
    </tr>
	
	<tr valign="top">
        <td><code>source.p_mode</code></td>
        <td>optional input to control whether the input pressure is injected as a mass source or enforced as a dirichlet boundary condition; valid inputs are <code>'additive'</code> (the default) or <code>'dirichlet'</code></td>
    </tr>	

    <tr valign="top">
        <td><code>source.ux</code></td>
        <td>time varying particle velocity in the x-direction (axial) at each of the source positions given by <code>source.u_mask</code></td>
    </tr>     

    <tr valign="top">
        <td><code>source.uy</code></td>
        <td>time varying particle velocity in the y-direction (radial) at each of the source positions given by <code>source.u_mask</code></td>
    </tr>       

    <tr valign="top">
        <td><code>source.u_mask</code></td>
        <td>binary matrix specifying the positions of the time varying particle velocity distribution</td>
    </tr> 
	
	<tr valign="top">
        <td><code>source.u_mode</code></td>
        <td>optional input to control whether the input velocity is applied as a force source or enforced as a dirichlet boundary condition; valid inputs are <code>'additive'</code> (the default) or <code>'dirichlet'</code></td>
    </tr>	

    <tr valign="top">
        <td>&nbsp</td>
        <td>&nbsp</td>
    </tr>     
    
    <tr valign="top">
        <td><code>sensor.mask*</code></td>
        <td>binary matrix or a set of Cartesian points where the pressure is recorded at each time-step</td>
    </tr>    
    
	<tr valign="top">
        <td><code>sensor.record</code></td>
        <td>cell array of the acoustic parameters to record in the form <code>sensor.record = {'p', 'u', ...}</code>; valid inputs are:<br/>
        <code>&nbsp;&nbsp;'p'</code> (acoustic pressure)<br/>
        <code>&nbsp;&nbsp;'p_max'</code> (maximum pressure)<br/>
        <code>&nbsp;&nbsp;'p_min'</code> (minimum pressure)<br/>
        <code>&nbsp;&nbsp;'p_rms'</code> (RMS pressure)<br/>
        <code>&nbsp;&nbsp;'p_final'</code> (final pressure field at all grid points)<br/>
        <code>&nbsp;&nbsp;'p_max_all'</code> (maximum pressure at all grid points)<br/>
        <code>&nbsp;&nbsp;'p_min_all'</code> (minimum pressure at all grid points)<br/>
        <code>&nbsp;&nbsp;'u'</code> (particle velocity)<br/>
        <code>&nbsp;&nbsp;'u_max'</code> (maximum particle velocity)<br/>
        <code>&nbsp;&nbsp;'u_min'</code> (minimum particle velocity)<br/>
        <code>&nbsp;&nbsp;'u_rms'</code> (RMS particle velocity)<br/>
        <code>&nbsp;&nbsp;'u_final'</code> (final particle velocity field at all grid points)<br/>
        <code>&nbsp;&nbsp;'u_max_all'</code> (maximum particle velocity at all grid points)<br/>
        <code>&nbsp;&nbsp;'u_min_all'</code> (minimum particle velocity at all grid points)<br/>
        <code>&nbsp;&nbsp;'u_non_staggered'</code> (particle velocity on non-staggered grid)<br/>
        <code>&nbsp;&nbsp;'I'</code> (time varying acoustic intensity)<br/>
        <code>&nbsp;&nbsp;'I_avg'</code> (average acoustic intensity)</td>
    </tr>
    
    <tr valign="top">
        <td><code>sensor.record_start_index</code></td>
        <td>time index at which the sensor should start recording the data specified by <code>sensor.record</code> (default = 1)</td>
    </tr> 
    
    <tr valign="top">
        <td><code>sensor.time_reversal_boundary_data</code></td>
        <td>time varying pressure enforced as a Dirichlet boundary condition over <code>sensor.mask</code></td>
    </tr>      
    
    <tr valign="top">
        <td><code>sensor.frequency_response</code></td>
        <td>two element array specifying the center frequency and percentage bandwidth of a frequency domain Gaussian filter applied to the <code>sensor_data</code></td>
    </tr>    
	
</table>
    
<ul>
    <table cellspacing="0" class="note" summary="Note" cellpadding="5" border="1">
        <tr width="90%">
            <td><b>Note</b>&nbsp;&nbsp;For a heterogeneous medium, <code>medium.sound_speed</code> and <code>medium.density</code> must be given in matrix form with the same dimensions as <code>kgrid</code>. For a homogeneous medium, these can be given as scalar values. If the medium is homogeneous and velocity inputs or outputs are not required, it is not necessary to specify <code>medium.density</code>.</td>
        </tr>
    </table>
</ul>

<h2>Optional Inputs</h2>

<p>Optional 'string', value pairs that may be used to modify the default computational settings.</p>

<table cellspacing="0" class="body" cellpadding="4" border="2">
    <colgroup>
        <col width="18%"><col width="18%"><col width="18%"><col width="46%">
    </colgroup>
    
    <thead>
        <tr valign="top">
            <th bgcolor="#B2B2B2">Input</th>
            <th bgcolor="#B2B2B2">Valid Settings</th>
            <th bgcolor="#B2B2B2">Default</th>
            <th bgcolor="#B2B2B2">Description</th>
        </tr>
    </thead>
    
    <tbody>

        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'CartInterp'</code></td>
            <td bgcolor="#F2F2F2"><code>'linear'</code><br><code>'nearest'</code></td>
            <td bgcolor="#F2F2F2"><code>'linear'</code></td>            
            <td bgcolor="#F2F2F2">Interpolation mode used to extract the pressure when a Cartesian sensor mask is given. If set to <code>'nearest'</code> and more than one Cartesian point maps to the same grid point, duplicated data points are discarded and <code>sensor_data</code> will be returned with less points than that specified by <code>sensor.mask</code>.</td>
        </tr>
    
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'CreateLog'</code></td>
            <td bgcolor="#F2F2F2"><em>(Boolean scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>false</code></td>            
            <td bgcolor="#F2F2F2">Boolean controlling whether the command line output is saved using the diary function with a date and time stamped filename.</td>
        </tr>        
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'DataCast'</code></td>
            <td bgcolor="#F2F2F2"><em>(string of data type)</em></td>
            <td bgcolor="#F2F2F2"><code>'off'</code></td>            
            <td bgcolor="#F2F2F2">String input of the data type that variables are cast to before computation. For example, setting to <code>'single'</code> will speed up the computation time (due to the improved efficiency of <code><a href="matlab: doc fftn">fftn</a></code> and <code><a href="matlab: doc ifftn">ifftn</a></code> for this data type) at the expense of a loss in precision. This variable is also useful for utilising GPU parallelisation through libraries such as the Parallel Computing Toolbox by setting <code>'DataCast'</code> to <code>'gpuArray-single'</code>.</td>
        </tr>    
        
		<tr valign="top">
            <td bgcolor="#F2F2F2"><code>'DataRecast'</code></td>
            <td bgcolor="#F2F2F2"><em>(Boolean scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>false</code></td>            
            <td bgcolor="#F2F2F2">Boolean controlling whether the output data is cast back to double precision. If set to false, <code>sensor_data</code> will be returned in the data format set using the <code>'DataCast'</code> option.</td>
        </tr>         
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'DisplayMask'</code></td>
            <td bgcolor="#F2F2F2"><em>(binary matrix)</em> or<br/><code>'off'</code></td>
            <td bgcolor="#F2F2F2"><code>sensor.mask</code></td>            
            <td bgcolor="#F2F2F2">Binary matrix overlaid onto the animated simulation display. Elements set to 1 within the display mask are set to black within the display.</td>
        </tr>   

		<tr valign="top">
            <td bgcolor="#F2F2F2"><code>'HDFCompressionLevel'</code></td>
            <td bgcolor="#F2F2F2"><em>(Integer scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>0</code></td>            
            <td bgcolor="#F2F2F2">Compression level used for writing the input HDF5 file when using <code>'SaveToDisk'</code> or <code><a href="kspaceFirstOrderASC.html">kspaceFirstOrderASC</a></code>. Can be set to an integer between 0 (no compression) and 9 (maximum compression). The compression is lossless. Increasing the compression level will reduce the file size if there are portions of the medium that are homogeneous, but will also increase the time to create the HDF5 file.</td>
        </tr>     		

        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'LogScale'</code></td>
            <td bgcolor="#F2F2F2"><em>(Boolean scalar)</em> or<br/><em>(numeric scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>false</code></td>            
            <td bgcolor="#F2F2F2">Boolean controlling whether the pressure field is log compressed before display. The data is compressed by scaling both the positive and negative values between 0 and 1 (truncating the data to the given plot scale), adding a scalar value (compression factor) and then using the corresponding portion of a log10 plot for the compression (the negative parts are remapped to be negative thus the default color scale will appear unchanged). The amount of compression can be controlled by adjusting the compression factor which can be given in place of the Boolean input. The closer the compression factor is to zero, the steeper the corresponding part of the log10 plot used, and the greater the compression (the default compression factor is 0.02).<p></td>
        </tr>

        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'MeshPlot'</code></td>
            <td bgcolor="#F2F2F2"><em>(Boolean scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>false</code></td>            
            <td bgcolor="#F2F2F2">Boolean controlling whether <code><a href="matlab: doc mesh">mesh</a></code> is used in place of <code><a href="matlab: doc imagesc">imagesc</a></code> to plot the pressure field. When <code>'MeshPlot'</code> is set to <code>true</code>, the default display mask is set to <code>'off'</code>.</td>
        </tr> 		
		
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'MovieArgs'</code></td>
            <td bgcolor="#F2F2F2"><em>(string cell array)</em></td>
            <td bgcolor="#F2F2F2"><code>{}</code></td>            
            <td bgcolor="#F2F2F2">Settings for <code><a href="matlab: doc VideoWriter">VideoWriter</a></code>. Parameters must be given as {'param', value, ...} pairs within a cell array (default = {}), where 'param' corresponds to a writable property of a VideoWriter object.</td>
        </tr> 

        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'MovieName'</code></td>
            <td bgcolor="#F2F2F2"><em>(string)</em></td>
            <td bgcolor="#F2F2F2"><code>'date-time-kspaceFirstOrder2D'</code></td>            
            <td bgcolor="#F2F2F2">Name of the movie produced when <code>'RecordMovie'</code> is set to <code>true</code>.</td>
        </tr> 
        
		<tr valign="top">
            <td bgcolor="#F2F2F2"><code>'MovieProfile'</code></td>
            <td bgcolor="#F2F2F2"><em>(string)</em></td>
            <td bgcolor="#F2F2F2"><code>'Uncompressed AVI'</code></td>            
            <td bgcolor="#F2F2F2">Profile input passed to <code><a href="matlab: doc VideoWriter">VideoWriter</a></code>.</td>
        </tr>        

        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'PlotFreq'</code></td>
            <td bgcolor="#F2F2F2"><em>(integer numeric scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>10</code></td>            
            <td bgcolor="#F2F2F2">The number of iterations which must pass before the simulation plot is updated.</td>
        </tr>        
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'PlotLayout'</code></td>
            <td bgcolor="#F2F2F2"><em>(Boolean scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>false</code></td>            
            <td bgcolor="#F2F2F2">Boolean controlling whether a four panel plot of the initial simulation layout is produced (initial pressure, sensor mask, sound speed, density).</td>
        </tr>        
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'PlotPML'</code></td>
            <td bgcolor="#F2F2F2"><em>(Boolean scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>true</code></td>            
            <td bgcolor="#F2F2F2">Boolean controlling whether the perfectly matched layer is shown in the simulation plots. If set to <code>false</code>, the PML is not displayed.<p></td>
        </tr>

        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'PlotScale'</code></td>
            <td bgcolor="#F2F2F2"><em>(numeric two element vector)</em> or<br><code>'auto'</code></td>
            <td bgcolor="#F2F2F2"><code>[-1, 1]</code></td>            
            <td bgcolor="#F2F2F2">[min, max] values used to control the scaling for <code><a href="matlab: doc imagesc">imagesc</a></code> (visualisation). If set to <code>'auto'</code>, a symmetric plot scale is chosen automatically for each plot frame.</td>
        </tr>            
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'PlotSim'</code></td>
            <td bgcolor="#F2F2F2"><em>(Boolean scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>true</code></td>            
            <td bgcolor="#F2F2F2">Boolean controlling whether the simulation iterations are progressively plotted.</td>
        </tr>            
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'PMLAlpha'</code></td>
            <td bgcolor="#F2F2F2"><em>(numeric scalar or three element vector)</em></td>
            <td bgcolor="#F2F2F2"><code>2</code></td>            
            <td bgcolor="#F2F2F2">Absorption within the perfectly matched layer in Nepers per grid point.</td>
        </tr>        
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'PMLInside'</code></td>
            <td bgcolor="#F2F2F2"><em>(Boolean scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>true</code></td>            
            <td bgcolor="#F2F2F2">Boolean controlling whether the perfectly matched layer is inside or outside the grid. If set to <code>false</code>, the input grids are enlarged by <code>PMLSize</code> before running the simulation.</td>
        </tr>            
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'PMLSize'</code></td>
            <td bgcolor="#F2F2F2"><em>(integer numeric scalar or three element vector)</em></td>
            <td bgcolor="#F2F2F2"><code>10</code></td>            
            <td bgcolor="#F2F2F2">Size of the perfectly matched layer in grid points. By default, the PML is added evenly to all sides of the grid, however, both <code>PMLSize</code> and <code>PMLAlpha</code> can be given as two element arrays to specify the x and y properties, respectively. To remove the PML, set the appropriate <code>PMLAlpha</code> to zero rather than forcing the PML to be of zero size.</td>
        </tr>
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'RadialSymmetry'</code></td>
            <td bgcolor="#F2F2F2"><em>(string)</em></td>
            <td bgcolor="#F2F2F2"><code>'WSWA-FFT'</code></td>            
            <td bgcolor="#F2F2F2">Radial symmetry assumed at the inner and outer domain boundaries by the simulation, where W: whole sample, H: half sample, S: symmetric, A: antisymmetric. Valid inputs are <code>'WSWA-FFT'</code>, <code>'WSWS-FFT'</code>, <code>'WSWA'</code>, and <code>'WSWS'</code>. The first two options are computed using the FFT by mirroring the domain appropriately. The final two options are computed using the discrete cosine and sine transformation and require additional functions (not currently part of k-Wave).</td>
        </tr>
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'RecordMovie'</code></td>
            <td bgcolor="#F2F2F2"><em>(Boolean scalar)</em></td>
            <td bgcolor="#F2F2F2"><code>false</code></td>            
            <td bgcolor="#F2F2F2">Boolean controlling whether the displayed image frames are captured and stored as a movie using <code><a href="matlab: doc VideoWriter">VideoWriter</a></code>.</td>
        </tr>          
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><code>'Smooth'</code></td>
            <td bgcolor="#F2F2F2"><em>(Boolean scalar or three element vector)</em></td>
            <td bgcolor="#F2F2F2"><code>[true, false, false]</code></td>            
            <td bgcolor="#F2F2F2">Boolean controlling whether <code>source.p0</code>, <code>medium.sound_speed</code>, and <code>medium.density</code> are smoothed using <code><a href="smooth.html">smooth</a></code> before computation. <code>'Smooth'</code> can either be given as a single Boolean value or as a 3 element array to control the smoothing of <code>source.p0</code>, <code>medium.sound_speed</code>, and <code>medium.density</code>, independently.</td>
        </tr>      
        
    </tbody>
</table>

<h2>Outputs</h2>

<p>If <code>sensor.record</code> is not defined by the user:</p>

<table class="body">
    <tr valign="top">
        <td width = "150"><code>sensor_data</code></td>
        <td>time varying pressure recorded at the sensor positions given by <code>sensor.mask</code></td>
    </tr>  
</table>

<p>If <code>sensor.record</code> is defined by the user:</p>

<table class="body">
    <tr valign="top">
        <td width = "150"><code>sensor_data.p</code></td>
        <td>time varying pressure recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'p'</code> is set)</td>
    </tr>
	<tr valign="top">
        <td width = "150"><code>sensor_data.p_max</code></td>
        <td>maximum pressure recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'p_max'</code> is set)</td>
    </tr>
	<tr valign="top">
        <td width = "150"><code>sensor_data.p_min</code></td>
        <td>minimum pressure recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'p_min'</code> is set)</td>
    </tr>      
	<tr valign="top">
        <td width = "150"><code>sensor_data.p_rms</code></td>
        <td>rms of the time varying pressure recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'p_rms'</code> is set)</td>
    </tr>
    <tr valign="top">
        <td width = "150"><code>sensor_data.p_final</code></td>
        <td>final pressure field at all grid points within the domain (returned if <code>'p_final'</code> is set)</td>
    </tr>
	<tr valign="top">
        <td width = "150"><code>sensor_data.p_max_all</code></td>
        <td>maximum pressure recorded at all grid points within the domain (returned if <code>'p_max_all'</code> is set)</td>
    </tr>
	<tr valign="top">
        <td width = "150"><code>sensor_data.p_min_all</code></td>
        <td>minimum pressure recorded at all grid points within the domain (returned if <code>'p_min_all'</code> is set)</td>
    </tr>      
    <tr valign="top">
        <td width = "150"><code>sensor_data.ux</code></td>
        <td>time varying particle velocity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u'</code> is set)</td>
    </tr>
    <tr valign="top">
        <td width = "150"><code>sensor_data.uy</code></td>
        <td>time varying particle velocity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u'</code> is set)</td>
    </tr>
    <tr valign="top">
        <td width = "150"><code>sensor_data.ux_max</code></td>
        <td>maximum particle velocity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_max'</code> is set)</td>
    </tr>
	<tr valign="top">
        <td width = "150"><code>sensor_data.uy_max</code></td>
        <td>maximum particle velocity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_max'</code> is set)</td>
    </tr> 
    <tr valign="top">
        <td width = "150"><code>sensor_data.ux_min</code></td>
        <td>minimum particle velocity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_min'</code> is set)</td>
    </tr>
	<tr valign="top">
        <td width = "150"><code>sensor_data.uy_min</code></td>
        <td>minimum particle velocity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_min'</code> is set)</td>
    </tr>   
    <tr valign="top">
        <td width = "150"><code>sensor_data.ux_rms</code></td>
        <td>rms of the time varying particle velocity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_rms'</code> is set)</td>
    </tr>
    <tr valign="top">
        <td width = "150"><code>sensor_data.uy_rms</code></td>
        <td>rms of the time varying particle velocity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_rms'</code> is set)</td>
    </tr>
    <tr valign="top">
        <td width = "150"><code>sensor_data.ux_final</code></td>
        <td>final particle velocity field in the x-direction at all grid points within the domain (returned if <code>'u_final'</code> is set)</td>
    </tr>
    <tr valign="top">
        <td width = "150"><code>sensor_data.uy_final</code></td>
        <td>final particle velocity field in the y-direction at all grid points within the domain (returned if <code>'u_final'</code> is set)</td>
    </tr>
    <tr valign="top">
        <td width = "150"><code>sensor_data.ux_max_all</code></td>
        <td>maximum particle velocity in the x-direction recorded at all grid points within the domain (returned if <code>'u_max_all'</code> is set)</td>
    </tr>
	<tr valign="top">
        <td width = "150"><code>sensor_data.uy_max_all</code></td>
        <td>maximum particle velocity in the y-direction recorded at all grid points within the domain (returned if <code>'u_max_all'</code> is set)</td>
    </tr> 
    <tr valign="top">
        <td width = "150"><code>sensor_data.ux_min_all</code></td>
        <td>minimum particle velocity in the x-direction recorded at all grid points within the domain (returned if <code>'u_min_all'</code> is set)</td>
    </tr>
	<tr valign="top">
        <td width = "150"><code>sensor_data.uy_min_all</code></td>
        <td>minimum particle velocity in the y-direction recorded at all grid points within the domain (returned if <code>'u_min_all'</code> is set)</td>
    </tr>      
    <tr valign="top">
        <td width = "150"><code>sensor_data.ux_non_staggered</code></td>
        <td>time varying particle velocity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> after shifting to the non-staggered grid (returned if <code>'u_non_staggered'</code> is set)</td>
    </tr>
    <tr valign="top">
        <td width = "150"><code>sensor_data.uy_non_staggered</code></td>
        <td>time varying particle velocity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> after shifting to the non-staggered grid (returned if <code>'u_non_staggered'</code> is set)</td>
    </tr>    
    <tr valign="top">
        <td width = "150"><code>sensor_data.Ix</code></td>
        <td>time varying acoustic intensity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'I'</code> is set)</td>
    </tr>
    <tr valign="top">
        <td width = "150"><code>sensor_data.Iy</code></td>
        <td>time varying acoustic intensity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'I'</code> is set)</td>
    </tr>	
    <tr valign="top">
        <td width = "150"><code>sensor_data.Ix_avg</code></td>
        <td>average acoustic intensity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'I_avg'</code> is set)</td>
    </tr>
    <tr valign="top">
        <td width = "150"><code>sensor_data.Iy_avg</code></td>
        <td>average acoustic intensity in the z-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'I_avg'</code> is set)</td>
    </tr>
</table>

<h2>Examples</h2>
<ul>
	<li><a href="example_ivp_axisymmetric_simulation.html">Simulations In An Axisymmetric Coordinate System</a></li>
</ul>

<h2>See Also</h2>

<code><a href="kspaceFirstOrder1D.html">kspaceFirstOrder1D</a></code>, <code><a href="kspaceFirstOrder2D.html">kspaceFirstOrder2D</a></code>, <code><a href="kspaceFirstOrder3D.html">kspaceFirstOrder3D</a></code>, <code><a href="kWaveGrid.html">kWaveGrid</a></code>

</div></body></html>